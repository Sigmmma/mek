Rewrite map definition so tags are loaded on-demand rather than all at once
    Do this by making a new FieldType and have the MapTag store a reference to the buffer of the map.
    The widget for the block will not display the tag until the "show" button is clicked.
    Once it is, the tag meta is parsed from the MapTag's buffer reference.
    When the map is re-written, the set_pointers needs to be False and the MapTag's
        buffer needs to be written to the map before anything else is written to it

    More needs to be done and it all needs to be thought out more, but I believe that's the general method

    ALSO PUT A BUTTON IN THE TAG META WIDGET TO TURN THE META INTO A TAG

Mozzarilla
    Halo-specific tab with special commands like add/remove sauce(opens window), open
       map with ability to browse it and load tags, convert one tag into another(xbox to pc), etc

Find out why hashcacher is taking a long ass time on simple stuff like senv tags(about 2.5 seconds for each)

HashCacher will need to:
    prune compressed vertices before calculating a gbxmodel's hash
    prune compressed lightmap data and other data not saved in a map(script syntax and
        string data and maybe also editor data)

    prune compressed_color_plate_data from bitmap tags


make program to load all hud, shader_environment, shader_model, and bitmap 
tags it can find, load all bitmaps referenced within those tags, pass them 
to the bitmap convertor with settings specifying how to convert them.
*shader_environment requires the bump maps to be turned into P-8 bump
*shader_model requires multipurpose maps to have their channels swapped
(this also means change the channel usage enum in the shader_model


## MAP RIPPING ##
When ripping a map with deprotect on, make a "Requires" set and a 
"Required_By" list for each tag. The Requires set will contain the
Tag_IDs of all tags that the tag requires to have valid names before
it is written and the value in the Required_By list will be a list of all
blocks that point to that Tag_ID.

When scanning through the tags, add each non-null Tag_Index_Ref
block to the Required_By list of the tag it points to, and add the Tag_ID
of the tag it points to to the current tag's Requires set. Set each of those
Tag_Index_Ref blocks Tag_Path_Pointer to 0 and Tag_ID fields to
0xFFFFFFFF. Set each of the Reflexive blocks ID and Reflexive_ID to 0
as well as the same kind of fields in Raw_Data_Ref.

When done, write the meta data of all the tags whose Tag_IDs have an empty 
Requires set to a BytearrayBuffer(not including the tag header), and make 
a hash of the buffer. Use this hash to find the name of the tag in the Hash_Cache
and, if it fails, name it heuristically. Replace the Tag_Path string of all blocks
that depend on it with the new name and(in a separate series of lists) remove
the name from lists that say "some_tag" depends on that tag.

Check each tag to see which ones have an empty Requires set and run the
above paragraph of steps on it. Repeat this process until all tags have
been written. If there is a point where no tags have an empty Requires
set, either name it heuristically or ask the user what to name it.

MAKE SURE TO REMOVE compressed_color_plate_data from bitmap tags
when making their hashes as well as compressed vertices in models and bsp

## MAP RIPPING ##




ARBYTMAP TODO:

Make sure the linear size is computed correctly for DDS headers
Finish DDS importer
Incorporate CHANNEL_ORDER into raw packers and unpackers. use it by
	getting which index A, R, G, and B are in and use those
	indexes as the locations to place the unpacked channels into

	not sure how I'm going to incorporate it in non raw formats(DXT)

Make setting to use same palette for all mipmaps of a bitmap
Write palettized mipmap generator.
    make it so that a palette can be supplied to the 
    mipmap generator so it already has one to work from